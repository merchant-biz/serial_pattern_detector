--------------------------------------------------------------------------------
-- Synchronous N-bit Serial Pattern Detector Testbench
--
-- @version 0.1.0
--
-- @author Jordan Downie <jpjdownie.biz@gmail.com>
-- @section LICENSE
-- 
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS
-- OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
-- NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-- DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-- (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-- LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-- ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--------------------------------------------------------------------------------
`timescale 1 ns / 1 ps
module serial_pattern_detector_vlg_tst();
// constants              
localparam N = 4;
localparam [N-1:0] PATTERN = 4'b1101;
localparam CLOCK_CYCLES = 50000; // number of full clock cycles to run
time clk_period = 20; // 20 ns period = 50 MHz     

// test vector input registers
reg clk = 0;
reg din = 0;
reg rst = 1;
// wires                                               
wire detect;

reg run_clk = 1'b1;

// DUT instantiation
serial_pattern_detector i1 (
    .clk(clk),
    .detect(detect),
    .din(din),
    .rst(rst)
);

initial begin
    #(clk_period);
    rst = 0;                           
    $display("Running testbench");                       
end                                                    

// Free-running clock, 20 ns period, gated by run_clk
always begin
    #(clk_period/2);
    if (run_clk)
        clk = ~clk;
end

// Stimulus for din: start after 30 ns, then every 20 ns assign a random value
initial begin
    #(30);  // wait 30 ns
    forever begin
        #(20);
        din = $random % 2; // random 0 or 1
    end
end

// Count posedges; when we hit CLOCK_CYCLES, stop the clock (and finish)
integer cycle_count = 0;
always @(posedge clk) begin
    cycle_count = cycle_count + 1;
    if (cycle_count == CLOCK_CYCLES) begin
        run_clk <= 1'b0;  // stop toggling in the clock generator
        //$finish; // end sim
    end
end

endmodule
